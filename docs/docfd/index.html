<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Docfd (Page WIP)</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 60%;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Docfd (Page WIP)</h1>
</header>
<p><a href=".."><strong>Back to Home</strong></a></p>
<h2 id="introduction">Introduction</h2>
<p><a href="https://github.com/darrenldl/docfd">Docfd</a> is in a TUI
program that allows you to fuzzy search for a phrase across multiple
lines, across text files, PDFs, DOCX, etc.</p>
<p>While the README does a reasonable job briefing over what Docfd is, I
still want to talk about Docfd in greater details. In part to document
the engineering effort that went into Docfd, and in part as a portfolio
building exercise.</p>
<h3 id="motivation">Motivation</h3>
<p>Docfd was born out of my personal frustrations with existing search
tools in the context of human text search.</p>
<p>This is not to say I think the tools are not well implemented or not
well designed, this is just me saying I don’t fit into the usage
patterns that these tools are designed for. In fact, given the specific
intended usage patterns and constraints, I think most of these tools are
likely implemented as well as one could.</p>
<p>So the following are not necessarily criticisms, but more of why they
didn’t fit my (perhaps admittedly niche) criteria of being able to run
locally on a not very powerful machine while providing “good” search
results:</p>
<ul>
<li><strong>grep, <a
href="https://github.com/BurntSushi/ripgrep">ripgrep</a>, etc</strong>
<ul>
<li>Great if I am searching for a single word</li>
<li>Bad if I want to search for a phrase across potentially more than 1
line
<ul>
<li>Technically there is a way to encode the problem into a regex,
e.g. “hello world” becomes <code>hello.*world</code>,
<code>hello.*\n.*world</code>, <code>hello.*\n.*\n.*world</code>, and so
on, up to a limit.</li>
<li>But then the number of regexes grows quickly with the number of
words, especially if we allow reordering of words and desire typo
tolerance.</li>
</ul></li>
</ul></li>
<li><strong><a href="https://github.com/junegunn/fzf">fzf</a>, <a
href="https://github.com/skim-rs/skim">skim</a>, <a
href="https://github.com/alexpasmantier/television">television</a></strong>
<ul>
<li>Great for fuzzy finding within a single line</li>
<li>There are workarounds for multiline by replacing the new line
character then using the <code>--read0</code> flag, e.g. <a
href="https://github.com/xkcd386at/scripts/blob/master/vgc">vgc</a>, but
this does not allow searching across blank lines</li>
<li>Technically not a problem if you are only interested in searching
within paragraphs, but this assumes text is always well formed, which is
not necessarily the case with text extracted from PDFs.</li>
</ul></li>
<li><strong><a
href="https://github.com/paperless-ngx/paperless-ngx">Paperless-ngx</a>,
<a href="https://github.com/papra-hq/papra">Papra</a>, <a
href="https://github.com/sist2app/sist2">sist2</a></strong>
<ul>
<li>These are optimised for central storage of documents, where the
storage is not necessarily designed to be accessible to external
programs (which is fair enough, cause you want storage
consistency).</li>
<li>But I still want to use the file system as the main organisation
mechanism to avoid vendor lock-in, and to allow usage of other tools. In
principle I can use both the central storage and file system, but then I
am using twice the storage space adn also need to keep things in sync
somehow.</li>
<li>That said, if I ever need to deploy for a use case for multi-user or
concurrent access, then software with DB backed storage is still likely
my top pick. But here I am just looking to use locally on a single
machine myself.</li>
</ul></li>
<li><strong><a href="https://www.recoll.org/">Recoll</a>, <a
href="https://invent.kde.org/frameworks/baloo">Baloo</a></strong>
<ul>
<li>These (from my point of view) expect either a stable main collection
of folders to scan from, or scan the whole home directory barring ones
like <code>Downloads</code>. They also utilise background daemon to
index periodically.</li>
<li>However, I usually jump to a specific project folder to search
rather than the whole home directory, and I want the index to be fully
up-to-date with respect to the underlying files. I don’t want to wait
for a background update to occur.</li>
<li>While I can trigger the reindexing manually, I need to update the
settings in order to just reindex the specific folder I am in.</li>
<li>On a similar note, I also don’t want the periodic CPU and/or memory
spike from reindexing of files I am not looking at.</li>
</ul></li>
<li><strong><a
href="https://www.elastic.co/elasticsearch">Elasticsearch</a>, <a
href="https://lucene.apache.org/">Lucene</a>, <a
href="https://github.com/meilisearch/meilisearch">meilisearch</a>,
etc</strong>
<ul>
<li>Nothing beats the search performance of actual search engines. But
the setup and running cost of these are not trivial.</li>
<li>Which are all fair enough, cause ultimately you need in-memory
indices for hot data to serve at the scale needed, which takes time to
build and they occupy memory space etc.</li>
<li>But I don’t want anything long running. I just want to jump into a
folder, do my search, and be done. I don’t want to wait for more than a
few seconds just to do a quick search, so starting up a fresh search
engine instance per session is a no-go.</li>
<li>I also don’t want the tool to disrupt other deskop applications I am
running, so the typical resource usage requirements of search engines
also render them not viable for me.</li>
<li>But if I am deploying onto a dedicated hardware/host, then these
remain the natural first choices obviously.</li>
</ul></li>
<li><strong>Local LLMs, whether for chat or semantic search</strong>
<ul>
<li>I personally believe these could be the gold standard for
information retrieval, but they are still very computationally heavy,
and there are a lot of fine-tuning needed in terms of chunking, etc, to
yield optimal results. And even after all that, we still face the issue
of hallucinations.</li>
<li>Arguments of the energy efficiency aside, I simply don’t want to
build my core workflow around needing very powerful hardware. Even CPU
optimised LLMs run quite sluggishly on my laptop last I tried.</li>
<li>If one day very powerful hardware is extremely prevalent and cheap,
where computational inefficiency is simply strong-armed into
irrelevance, then sure, local LLM why not. Or alternatively LLM becomes
so efficient that we can use it on the most modest of machines while
offering good results, that would suffice as well.</li>
<li>But I am not confident we are close to that stage yet, so there are
still very real needs for the traditional approaches to searching,
especially since LLMs still hallucinate wildly, and even if not, cannot
give guarantee for its exhaustiveness. For instance, if grep does not
give any results for a search word, then I am confident the word does
not exist in the documents, but I cannot say the same for LLMs.</li>
</ul></li>
</ul>
<h3 id="how-does-docfd-address-my-complaints">How does Docfd address my
complaints?</h3>
<ul>
<li>Docfd accomplishes multiline search through a straightforward
combination of inverted index and proximity search between words.
<ul>
<li>The inverted index (i.e. a mapping from a word to all its appearing
positions) is first searched through once to find the matches for the
first word in the search phrase.</li>
<li>DFS is then used for the remaining words, where the word is searched
within a specified distance from the previous word. In other words, the
path in this DFS is the list/sequence of words in the document matching
the search phrase.</li>
</ul></li>
<li>Fuzzy matching is handled by using the Levenshtein distance as part
of the matching criteria for each word. An automaton is computed for
each word of the search phrase for optimised repeated matching.</li>
<li>Docfd only processes the current directory or the specified
directories and files upon startup. Hashing is used to check if file has
been previously indexed. This means there is no central storage
requirement, and no background indexing.
<ul>
<li>In principle this causes slower start-up time in the general case
compared to programs with background indexing. But since the set of
documents of interest is usually small (&lt;1k documents), the start-up
is often instantaneous.</li>
<li>And if the set of documents is really large, then one can always
fall back to having a long running session of docfd.</li>
</ul></li>
<li>A common speed up tactic for search engines is to load the inverted
indices into memory, as they are on the hottest paths. Docfd instead
keeps it only in the on-disk SQLite DB to minimise memory usage, to
avoid impacting performance of other desktop applications. The tradeoff
is that at larger scale (say a few thousand documents, depending on the
sizes), Docfd will noticeably struggle - results will take seconds
instead of less than a second to show up.</li>
</ul>
<h3 id="structure-of-remaining-text">Structure of Remaining Text</h3>
<p>The rest of the Docfd text will revolve around showcasing the
different vertical slices (the specific scenarios or workflows) of Docfd
in the form of recordings, each followed by a technical write-up of how
the implementation all worked together into delivering said vertical
slice.</p>
<p>I believe this both delivers a nice feature exploration experience
for new and existing users, and splits the technical writing naturally
by tangible, focused scenarios.</p>
<h2 id="showcase">Showcase</h2>
</body>
</html>
